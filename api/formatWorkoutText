// api/formatWorkoutText.js

/**
 * @typedef {'warmup' | 'preset' | 'main' | 'postset' | 'cooldown' | 'unknown'} SectionName
 * @typedef {'sendoff' | 'rest' | 'none'} IntervalKind
 * @typedef {'free' | 'back' | 'breast' | 'fly' | 'im' | 'choice' | 'mixed'} Stroke
 * @typedef {'swim' | 'kick' | 'pull' | 'drill' | 'scull' | 'technique'} Mode
 * @typedef {'evenPace' | 'descend' | 'build' | 'other'} PatternType
 */

/**
 * @typedef {Object} Interval
 * @property {IntervalKind} kind
 * @property {number | null} seconds
 */

/**
 * @typedef {Object} Pattern
 * @property {PatternType} type
 * @property {number} [start]
 * @property {number} [end]
 * @property {string} [raw]
 */

/**
 * @typedef {Object} FormattedBlock
 * @property {string} displayText
 * @property {SectionName} section
 * @property {number} reps
 * @property {number | null} distance
 * @property {Stroke | null} stroke
 * @property {Mode | null} mode
 * @property {Interval} interval
 * @property {Pattern | null} pattern
 * @property {string[]} equipment
 * @property {string} notes
 */

/**
 * @typedef {Object} FormattedSection
 * @property {SectionName} name
 * @property {string} title
 * @property {FormattedBlock[]} blocks
 */

/**
 * @typedef {Object} FormatIssue
 * @property {number} lineNumber
 * @property {string} lineText
 * @property {string} reason
 */

/**
 * @typedef {Object} FormatWorkoutResponse
 * @property {FormattedSection[]} sections
 * @property {FormatIssue[]} issues
 * @property {string} normalizedText
 */

// üîÅ --- RETRY HELPER ---
async function fetchWithRetry(url, options, retries = 3) {
    for (let attempt = 0; attempt < retries; attempt++) {
        try {
            const res = await fetch(url, options);

            // If it's NOT a 503 overload, just return it.
            if (res.status !== 503) {
                return res;
            }

            // 503 -> exponential backoff and retry
            const delay = 400 * Math.pow(2, attempt); // 400ms, 800ms, 1600ms...
            await new Promise((resolve) => setTimeout(resolve, delay));
        } catch (err) {
            // Network failure ‚Äî retry unless last attempt
            if (attempt === retries - 1) throw err;
        }
    }

    // Last attempt: just return whatever happens
    return fetch(url, options);
}

// üîç --- VALIDATION FUNCTIONS ---

/**
 * Validate that value is one of the allowed enum values
 * @param {any} value
 * @param {string[]} allowed
 * @param {string} fieldName
 * @returns {boolean}
 */
function isValidEnum(value, allowed, fieldName) {
    if (typeof value !== 'string' || !allowed.includes(value)) {
        console.error(`Invalid ${fieldName}: ${value}. Must be one of: ${allowed.join(', ')}`);
        return false;
    }
    return true;
}

/**
 * Validate Interval object
 * @param {any} interval
 * @returns {boolean}
 */
function validateInterval(interval) {
    if (!interval || typeof interval !== 'object') {
        console.error('Interval must be an object');
        return false;
    }

    if (!isValidEnum(interval.kind, ['sendoff', 'rest', 'none'], 'interval.kind')) {
        return false;
    }

    if (interval.seconds !== null && typeof interval.seconds !== 'number') {
        console.error('Interval.seconds must be number or null');
        return false;
    }

    return true;
}

/**
 * Validate Pattern object
 * @param {any} pattern
 * @returns {boolean}
 */
function validatePattern(pattern) {
    if (pattern === null) return true;

    if (!pattern || typeof pattern !== 'object') {
        console.error('Pattern must be an object or null');
        return false;
    }

    if (!isValidEnum(pattern.type, ['evenPace', 'descend', 'build', 'other'], 'pattern.type')) {
        return false;
    }

    if (pattern.start !== undefined && typeof pattern.start !== 'number') {
        console.error('Pattern.start must be number or undefined');
        return false;
    }

    if (pattern.end !== undefined && typeof pattern.end !== 'number') {
        console.error('Pattern.end must be number or undefined');
        return false;
    }

    if (pattern.raw !== undefined && typeof pattern.raw !== 'string') {
        console.error('Pattern.raw must be string or undefined');
        return false;
    }

    return true;
}

/**
 * Validate FormattedBlock object
 * @param {any} block
 * @param {number} index
 * @returns {boolean}
 */
function validateBlock(block, index) {
    if (!block || typeof block !== 'object') {
        console.error(`Block ${index} must be an object`);
        return false;
    }

    // Required fields
    if (typeof block.displayText !== 'string') {
        console.error(`Block ${index}: displayText must be string`);
        return false;
    }

    if (!isValidEnum(block.section, ['warmup', 'preset', 'main', 'postset', 'cooldown', 'unknown'], `block ${index} section`)) {
        return false;
    }

    if (typeof block.reps !== 'number') {
        console.error(`Block ${index}: reps must be number`);
        return false;
    }

    if (block.distance !== null && typeof block.distance !== 'number') {
        console.error(`Block ${index}: distance must be number or null`);
        return false;
    }

    // Nullable stroke
    if (block.stroke !== null && !isValidEnum(block.stroke, ['free', 'back', 'breast', 'fly', 'im', 'choice', 'mixed'], `block ${index} stroke`)) {
        return false;
    }

    // Nullable mode
    if (block.mode !== null && !isValidEnum(block.mode, ['swim', 'kick', 'pull', 'drill', 'scull', 'technique'], `block ${index} mode`)) {
        return false;
    }

    // Interval (required)
    if (!validateInterval(block.interval)) {
        console.error(`Block ${index}: invalid interval`);
        return false;
    }

    // Pattern (nullable)
    if (!validatePattern(block.pattern)) {
        console.error(`Block ${index}: invalid pattern`);
        return false;
    }

    // Equipment array
    if (!Array.isArray(block.equipment)) {
        console.error(`Block ${index}: equipment must be array`);
        return false;
    }

    if (!block.equipment.every(e => typeof e === 'string')) {
        console.error(`Block ${index}: all equipment items must be strings`);
        return false;
    }

    // Notes
    if (typeof block.notes !== 'string') {
        console.error(`Block ${index}: notes must be string`);
        return false;
    }

    return true;
}

/**
 * Validate FormattedSection object
 * @param {any} section
 * @param {number} index
 * @returns {boolean}
 */
function validateSection(section, index) {
    if (!section || typeof section !== 'object') {
        console.error(`Section ${index} must be an object`);
        return false;
    }

    if (!isValidEnum(section.name, ['warmup', 'preset', 'main', 'postset', 'cooldown', 'unknown'], `section ${index} name`)) {
        return false;
    }

    if (typeof section.title !== 'string') {
        console.error(`Section ${index}: title must be string`);
        return false;
    }

    if (!Array.isArray(section.blocks)) {
        console.error(`Section ${index}: blocks must be array`);
        return false;
    }

    for (let i = 0; i < section.blocks.length; i++) {
        if (!validateBlock(section.blocks[i], i)) {
            console.error(`Section ${index}, block ${i} failed validation`);
            return false;
        }
    }

    return true;
}

/**
 * Validate FormatIssue object
 * @param {any} issue
 * @param {number} index
 * @returns {boolean}
 */
function validateIssue(issue, index) {
    if (!issue || typeof issue !== 'object') {
        console.error(`Issue ${index} must be an object`);
        return false;
    }

    if (typeof issue.lineNumber !== 'number') {
        console.error(`Issue ${index}: lineNumber must be number`);
        return false;
    }

    if (typeof issue.lineText !== 'string') {
        console.error(`Issue ${index}: lineText must be string`);
        return false;
    }

    if (typeof issue.reason !== 'string') {
        console.error(`Issue ${index}: reason must be string`);
        return false;
    }

    return true;
}

/**
 * Validate complete FormatWorkoutResponse
 * @param {any} response
 * @returns {boolean}
 */
function validateResponse(response) {
    if (!response || typeof response !== 'object') {
        console.error('Response must be an object');
        return false;
    }

    // Sections (required array)
    if (!Array.isArray(response.sections)) {
        console.error('Response.sections must be an array');
        return false;
    }

    for (let i = 0; i < response.sections.length; i++) {
        if (!validateSection(response.sections[i], i)) {
            return false;
        }
    }

    // Issues (required array)
    if (!Array.isArray(response.issues)) {
        console.error('Response.issues must be an array');
        return false;
    }

    for (let i = 0; i < response.issues.length; i++) {
        if (!validateIssue(response.issues[i], i)) {
            return false;
        }
    }

    // Normalized text (required string)
    if (typeof response.normalizedText !== 'string') {
        console.error('Response.normalizedText must be string');
        return false;
    }

    return true;
}

// üß† --- MAIN HANDLER ---

export default async function handler(req, res) {
    const MODEL = "models/gemini-2.5-flash";
    const ENDPOINT = `https://generativelanguage.googleapis.com/v1/${MODEL}:generateContent`;

    // Simple diagnostics route
    if (req.method === "GET") {
        return res.status(200).json({
            ok: true,
            model: MODEL,
            endpoint: ENDPOINT,
            build: process.env.VERCEL_GIT_COMMIT_SHA || "local",
        });
    }

    if (req.method !== "POST") {
        return res.status(405).json({ error: "Method not allowed" });
    }

    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
        return res.status(401).json({ error: "Missing Gemini API key" });
    }

    try {
        const { text, poolType = "SCY", defaultSection = "main" } = req.body || {};

        if (!text || !text.trim()) {
            return res.status(400).json({ error: "Missing workout text" });
        }

        // -----------------------
        // üß† FORMATTING PROMPT (OPTIMIZED)
        // -----------------------
        const prompt = `You are a swim workout formatter. Parse raw workout text into strict JSON.

**RULES:**
1. Output ONLY valid JSON. No markdown, no commentary.
2. Don't invent sets. Normalize notation. Flag unclear lines in "issues".

**CONTEXT:** Pool: ${poolType}, Default section: ${defaultSection}

**SCHEMA:**
{
  "sections": [{
    "name": "warmup"|"preset"|"main"|"postset"|"cooldown"|"unknown",
    "title": "Warmup"|"Pre-Set"|"Main Set"|"Post-Set"|"Cooldown",
    "blocks": [{
      "displayText": "4 x 50 free @ :50 ‚Äì descend 1‚Äì4",
      "section": "warmup",
      "reps": 4,
      "distance": 50,
      "stroke": "free"|"back"|"breast"|"fly"|"im"|"choice"|"mixed"|null,
      "mode": "swim"|"kick"|"pull"|"drill"|"scull"|"technique"|null,
      "interval": {"kind": "sendoff"|"rest"|"none", "seconds": 50|null},
      "pattern": {"type": "evenPace"|"descend"|"build"|"other", "start": 1, "end": 4, "raw": "descend 1‚Äì4"}|null,
      "equipment": ["fins"]|[],
      "notes": "text"
    }]
  }],
  "issues": [{"lineNumber": 5, "lineText": "text", "reason": "reason"}],
  "normalizedText": "Warmup\\n4 x 50..."
}

**QUICK REFERENCE:**
Sections: WU/Warmup‚Üíwarmup, Preset/Pre-Set‚Üípreset, Main‚Üímain, Post-Set‚Üípostset, CD/Cooldown‚Üícooldown
Reps: "8x50"‚Üí8,50 | "400"‚Üí1,400
Strokes: free/fr‚Üífree, back/bk‚Üíback, breast/br‚Üíbreast, fly‚Üífly, IM‚Üíim, choice‚Üíchoice, multiple‚Üímixed
Modes: kick/pull/drill/swim/scull/technique (if mentioned)
Intervals: "@1:10"‚Üísendoff,70 | ":50"‚Üísendoff,50 | "15 rest"‚Üírest,15 | none‚Üínone,null (normalize 1.10‚Üí1:10)
Patterns: descend/build‚Üítype+range | "easy/aerobic/fast"‚Üíother | none‚Üínull
Equipment: fins, paddles, snorkel, buoy, band, parachute (array)
Rounds: "3x through 4x50"‚Üíreps:12 + notes:"3 rounds"
Issues: No reps/distance + not header ‚Üí add to issues (lineNumber, lineText, reason)

**EXAMPLE:**
Input:
WU
8x25 kick @ :30

Main
3x through:
 4x50 fr @ :50 build
 2x100 IM @ 1.30 aerobic

Random note

Output:
{
  "sections": [
    {"name": "warmup", "title": "Warmup", "blocks": [
      {"displayText": "8 x 25 kick @ :30", "section": "warmup", "reps": 8, "distance": 25,
       "stroke": null, "mode": "kick", "interval": {"kind": "sendoff", "seconds": 30},
       "pattern": null, "equipment": [], "notes": ""}
    ]},
    {"name": "main", "title": "Main Set", "blocks": [
      {"displayText": "3 rounds: 4 x 50 free @ :50 ‚Äì build", "section": "main", "reps": 12,
       "distance": 50, "stroke": "free", "mode": null, "interval": {"kind": "sendoff", "seconds": 50},
       "pattern": {"type": "build", "raw": "build"}, "equipment": [], "notes": "3 rounds"},
      {"displayText": "3 rounds: 2 x 100 IM @ 1:30 ‚Äì aerobic", "section": "main", "reps": 6,
       "distance": 100, "stroke": "im", "mode": null, "interval": {"kind": "sendoff", "seconds": 90},
       "pattern": {"type": "other", "raw": "aerobic"}, "equipment": [], "notes": "3 rounds"}
    ]}
  ],
  "issues": [{"lineNumber": 8, "lineText": "Random note", "reason": "No clear reps/distance"}],
  "normalizedText": "Warmup\\n8 x 25 kick @ :30\\n\\nMain Set\\n3 rounds:\\n  4 x 50 free @ :50 ‚Äì build\\n  2 x 100 IM @ 1:30 ‚Äì aerobic"
}

**PARSE THIS WORKOUT:**
${text}

Output ONLY JSON. No markdown, no extra text.`;

        // üåä MAIN FORMATTING REQUEST (with retry)
        const resp = await fetchWithRetry(`${ENDPOINT}?key=${apiKey}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                contents: [{ role: "user", parts: [{ text: prompt }] }],
            }),
        });

        if (!resp.ok) {
            const errText = await resp.text();
            console.error(`Gemini API error ${resp.status}: ${errText}`);
            return res.status(502).json({ error: "Failed to contact formatting model" });
        }

        const data = await resp.json();

        if (!data?.candidates?.length) {
            console.error("No candidates in Gemini response");
            return res.status(502).json({
                error: "Model service temporarily unavailable",
            });
        }

        const raw = data.candidates[0]?.content?.parts?.[0]?.text ?? "";

        // Clean up potential markdown wrapping
        let cleaned = raw
            .replace(/```json\s*/g, "")
            .replace(/```\s*/g, "")
            .trim();

        // Parse JSON
        let parsed;
        try {
            parsed = JSON.parse(cleaned);
        } catch (parseError) {
            console.error("Failed to parse JSON from model:", parseError);
            console.error("Raw output:", raw);
            return res.status(500).json({ error: "Model returned invalid JSON" });
        }

        // Validate against schema
        if (!validateResponse(parsed)) {
            console.error("Validation failed for model output");
            return res.status(500).json({ error: "Model output failed validation" });
        }

        // ‚úÖ RETURN VALIDATED RESULT
        return res.status(200).json(parsed);

    } catch (err) {
        console.error("Unexpected error in formatWorkoutText:", err);

        let message = "An unexpected error occurred";
        const text = typeof err.message === "string" ? err.message : "";

        if (text.includes("fetch failed") || text.includes("ECONNREFUSED")) {
            message = "Network error connecting to model service";
        }

        return res.status(500).json({
            error: message,
        });
    }
}
